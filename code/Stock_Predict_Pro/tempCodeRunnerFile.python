# 导入所需的库
import akshare as ak
import numpy as np
from datetime import datetime, timedelta
from sklearn.preprocessing import MinMaxScaler
import torch
import torch.nn as nn
from torch.utils.data import DataLoader, TensorDataset
import torch.optim as optim
import random
import matplotlib.pyplot as plt

# 数据获取函数
def fetch_stock_data(symbol, start_date, end_date, adjust='hfq'):
    data = ak.stock_zh_a_hist(symbol=symbol, period="daily", start_date=start_date, end_date=end_date, adjust=adjust)
    return data

# 数据预处理函数
def preprocess_data(data, look_back=60):
    scaler = MinMaxScaler(feature_range=(-1, 1))
    scaled_data = scaler.fit_transform(data[['开盘', '最高', '最低', '收盘', '成交量']].values)
    X, y = [], []
    for i in range(look_back, len(scaled_data)):
        X.append(scaled_data[i-look_back:i, :])
        y.append(scaled_data[i, 3])  # 3 is the index of '收盘' price
    return np.array(X), np.array(y), scaler

# CNN-LSTM模型类
class CNNLSTM(nn.Module):
    def __init__(self, num_features, hidden_dim, kernel_size, num_layers, output_dim=1):
        super(CNNLSTM, self).__init__()
        self.cnn = nn.Conv1d(in_channels=num_features, out_channels=hidden_dim, kernel_size=kernel_size, stride=1, padding=kernel_size//2)
        self.relu = nn.ReLU()
        self.lstm = nn.LSTM(input_size=hidden_dim, hidden_size=hidden_dim, num_layers=num_layers, batch_first=True)
        self.fc = nn.Linear(hidden_dim, output_dim)

    def forward(self, x):
        x = x.permute(0, 2, 1)
        x = self.relu(self.cnn(x))
        x = x.permute(0, 2, 1)
        x, _ = self.lstm(x)
        x = x[:, -1, :]
        x = self.fc(x)
        return x

# 训练模型函数
def train_model(X_train, y_train, params):
    model = CNNLSTM(num_features=5, hidden_dim=params['hidden_dim'], kernel_size=params['kernel_size'], num_layers=params['num_layers'], output_dim=1)
    criterion = nn.MSELoss()
    optimizer = optim.Adam(model.parameters(), lr=0.001)
    
    train_data = TensorDataset(torch.from_numpy(X_train).float(), torch.from_numpy(y_train).float())
    train_loader = DataLoader(train_data, batch_size=64, shuffle=True)

    for epoch in range(100):  # 可根据需要调整epoch数量
        for inputs, targets in train_loader:
            optimizer.zero_grad()
            output = model(inputs)
            loss = criterion(output, targets.unsqueeze(1))
            loss.backward()
            optimizer.step()
    
    return model

# 遗传算法组件定义
class Individual:
    def __init__(self, param_space):
        self.param_space = param_space
        self.params = {k: random.choice(v) for k, v in param_space.items()}
        self.fitness = None

    def mutate(self, mutation_rate):
        for param in self.params:
            if random.random() < mutation_rate:
                self.params[param] = random.choice(self.param_space[param])

def crossover(parent1, parent2):
    child_params = {}
    for param in parent1.params:
        child_params[param] = parent1.params[param] if random.random() < 0.5 else parent2.params[param]
    return Individual(parent1.param_space), Individual(parent1.param_space)

def generate_initial_population(pop_size, param_space):
    return [Individual(param_space) for _ in range(pop_size)]

def compute_fitness(individual, X_train, y_train, X_val, y_val):
    model = train_model(X_train, y_train, individual.params)
    val_loss = evaluate_model(model, X_val, y_val)
    return 1 / val_loss

def evaluate_model(model, X_val, y_val):
    model.eval()
    with torch.no_grad():
        predictions = model(torch.from_numpy(X_val).float())
        val_loss = nn.MSELoss()(predictions, torch.from_numpy(y_val).float().unsqueeze(1))
    return val_loss.item()

def select_parents(population):
    population.sort(key=lambda x: x.fitness, reverse=True)
    return population[:2]

def genetic_algorithm(X_train, y_train, X_val, y_val, param_space, pop_size=10, num_generations=5, mutation_rate=0.1):
    population = generate_initial_population(pop_size, param_space)

    for generation in range(num_generations):
        for individual in population:
            individual.fitness = compute_fitness(individual, X_train, y_train, X_val, y_val)
        
        parents = select_parents(population)
        population = []

        for _ in range(pop_size // 2):
            child1, child2 = crossover(parents[0], parents[1])
            child1.mutate(mutation_rate)
            child2.mutate(mutation_rate)
            population.extend([child1, child2])

    best_individual = max(population, key=lambda x: x.fitness)
    return best_individual.params

# 预测和评估函数
def predict_and_evaluate(model, X_test, y_test, scaler):
    model.eval()
    with torch.no_grad():
        predictions = model(torch.from_numpy(X_test).float())
        predicted_prices = scaler.inverse_transform(predictions.numpy())
        actual_prices = scaler.inverse_transform(y_test.reshape(-1, 1))

    mse = nn.MSELoss()(predictions, torch.from_numpy(y_test).float().unsqueeze(1)).item()

    plt.figure(figsize=(12, 6))
    plt.plot(actual_prices, label='Actual Prices')
    plt.plot(predicted_prices, label='Predicted Prices')
    plt.title('Stock Price Prediction')
    plt.xlabel('Time')
    plt.ylabel('Price')
    plt.legend()
    plt.show()

    return mse

# 主流程
if __name__ == "__main__":
    # 获取数据
    today = datetime(2023, 12, 30)
    start_date = today - timedelta(days=365)
    end_date = today
    data = fetch_stock_data(symbol="000001", start_date=start_date.strftime('%Y%m%d'), end_date=end_date.strftime('%Y%m%d'), adjust="")

    # 预处理数据
    X, y, scaler = preprocess_data(data)
    split = data[data['日期'] == '2023-12-14'].index[0] - 60
    X_train, X_test = X[:split], X[split:]
    y_train, y_test = y[:split], y[split:]

    # 定义参数空间和运行遗传算法
    param_space = {
        'hidden_dim': [16, 32, 64],
        'kernel_size': [3, 5, 7],
        'num_layers': [1, 2, 3]
    }
    best_params = genetic_algorithm(X_train, y_train, X_test, y_test, param_space)

    # 使用最佳参数训练模型
    best_model = train_model(X_train, y_train, best_params)

    # 进行预测和评估
    mse = predict_and_evaluate(best_model, X_test, y_test, scaler)
    print("Mean Squared Error on Test Set:", mse)
